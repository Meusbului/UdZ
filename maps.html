<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Maps - myGW</title>
    <!-- Use Inter font to match index page branding -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Leaflet CSS for interactive map -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="screen">
    <header class="top" style="position:relative;z-index:20">
      <div class="top-inner">
        <div class="brand">
          <div class="brand-text">
            <a href="index.html" class="brand-link">
              <div class="brand-title">myGW</div>
              <div class="brand-sub">WE MOVE FOR YOU</div>
            </a>
          </div>
        </div>
        <a href="index.html" class="header-badge-link" aria-label="Back to home"><span class="badge placeholder-orange" aria-hidden="true"></span></a>
      </div>
    </header>

    <!-- Fullscreen interactive map (Leaflet) - header stays above -->
    <div id="map" style="position:fixed;inset:0;z-index:0"></div>
    <!-- Locate control: positioned bottom-right above the status toast; pushed further down -->
    <div id="locateControl" style="position:fixed;right:12px;bottom:56px;z-index:30;bottom:calc(56px + env(safe-area-inset-bottom));">
      <button id="locateBtn" style="background:#ff6a00;color:#fff;border:none;padding:10px 12px;border-radius:10px;font-weight:600;box-shadow:0 6px 18px rgba(0,0,0,0.12);">Locate</button>
    </div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <!-- Firebase (compat) - paste your config into firebaseConfig below -->
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>
    <script>
      document.addEventListener('DOMContentLoaded', function(){
        // Center roughly where the previous bbox was (lat, lon)
        var centerLat = 47.55, centerLon = 9.725;
  var map = L.map('map', {zoomControl:false, attributionControl:false}).setView([centerLat, centerLon], 11);

        // Dark tiles (CartoDB Dark Matter)
        L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
          maxZoom: 19,
          detectRetina: false,
          attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; CARTO'
        }).addTo(map);

        // Minor CSS tweak to reduce visible tile seams on some mobile browsers
        var style = document.createElement('style');
        style.innerHTML = '\n          .leaflet-tile { background-color: #111; image-rendering: -webkit-optimize-contrast; }\n          .leaflet-tile-loaded { opacity: 1; }\n        ';
        document.head.appendChild(style);

        // ensure header sits above the map
        var header = document.querySelector('.top');
        if(header) header.style.zIndex = 20;

        // --- Realtime users (Firebase) -------------------------
        // NOTE: Replace the firebaseConfig object below with your project's values.
    var firebaseConfig = {
          apiKey: "AIzaSyDMk6wT1PzGn2pFp38mqEX4WmuojM8DTpo",
          authDomain: "udz-mobile-b27a6.firebaseapp.com",
          projectId: "udz-mobile-b27a6",
          storageBucket: "udz-mobile-b27a6.appspot.com",
          messagingSenderId: "1098341273373",
          appId: "1:1098341273373:web:4e71e3ea33c44651b01bf4",
          measurementId: "G-4BSDR5S34K"
        };
  var firebaseInitialized = false;
  var firestore = null;
  var clientId = localStorage.getItem('mgw_clientId') || null; // will prefer auth.uid once signed in
        var displayName = localStorage.getItem('mgw_name') || '';
        var userMarkers = {}; // markers keyed by clientId
  // shared canvas renderer and pending update queue for better performance with many markers
  var markerRenderer = L.canvas({ padding: 0.5 });
  var pendingUpdates = {};
  var flushScheduled = false;
        var onlineCountEl = document.createElement('div');
        onlineCountEl.style.cssText = 'position:fixed;left:12px;bottom:16px;z-index:9999;color:#fff;background:rgba(0,0,0,0.45);padding:6px 10px;border-radius:8px;font-size:13px';
        onlineCountEl.textContent = '';
        document.body.appendChild(onlineCountEl);

        // Debug overlay to surface auth/errors for troubleshooting
        var debugEl = document.createElement('div');
        debugEl.style.cssText = 'position:fixed;left:12px;bottom:72px;z-index:9999;color:#fff;background:rgba(0,0,0,0.6);padding:8px 10px;border-radius:8px;font-size:12px;max-width:320px;line-height:1.2';
        debugEl.id = 'mgw_debug';
        debugEl.innerHTML = '<strong>Debug:</strong><div id="mgw_debug_state">init</div>';
        document.body.appendChild(debugEl);

        function setDebug(msg){
          try{ document.getElementById('mgw_debug_state').textContent = String(msg); }catch(e){ console.log('dbg', msg); }
        }

        function initFirebase(){
          if(firebaseInitialized) return;
          try{
            firebase.initializeApp(firebaseConfig);
            // sign in anonymously, then hook Firestore listeners
            firebase.auth().signInAnonymously().then(function(userCred){
              clientId = userCred && userCred.user ? userCred.user.uid : clientId;
              if(clientId) localStorage.setItem('mgw_clientId', clientId);
              setDebug('signed in: ' + clientId);
              firestore = firebase.firestore();
              listenForLocations();
              firebaseInitialized = true;
            }).catch(function(err){
              console.warn('Anonymous auth failed:', err);
              setDebug('auth error: ' + (err && err.message));
              // fallback: initialize Firestore without auth (may be rejected by rules)
              try{ firestore = firebase.firestore(); listenForLocations(); firebaseInitialized = true; setDebug('firestore init (no auth)'); }catch(e){ setDebug('firestore init failed'); }
            });
            // also show auth state changes
            firebase.auth().onAuthStateChanged(function(u){ if(u){ setDebug('auth state: uid=' + u.uid); clientId = u.uid; if(clientId) localStorage.setItem('mgw_clientId', clientId); } else { setDebug('auth state: signed out'); } });
          }catch(e){
            console.warn('Firebase init failed', e);
          }
        }

        function publishLocation(lat, lon, acc){
          if(!firebaseInitialized) initFirebase();
          if(!firestore || !clientId) return; // wait for auth
          var docRef = firestore.collection('locations').doc(clientId);
          // include an expiresAt timestamp so Firestore TTL (if enabled) will remove inactive docs
          var expiresMs = Date.now() + 60000; // expire ~60s from publish
          var expiresTs = (firebase && firebase.firestore && firebase.firestore.Timestamp) ? firebase.firestore.Timestamp.fromMillis(expiresMs) : null;
          var payload = { id: clientId, name: displayName || null, lat: lat, lon: lon, acc: acc||0, ts: Date.now(), expiresAt: expiresTs };
          docRef.set(payload).then(function(){ setDebug('published at ' + new Date().toLocaleTimeString()); }).catch(function(e){ console.warn('publish failed', e); setDebug('publish error: ' + (e && e.message)); });
        }

        function removeMyLocation(){
          if(!firebaseInitialized || !firestore || !clientId) return;
          try{ firestore.collection('locations').doc(clientId).delete().then(function(){ setDebug('removed my location'); }).catch(function(e){ setDebug('remove error: ' + (e && e.message)); }); }catch(e){ setDebug('remove exception'); }
        }

        function listenForLocations(){
          if(!firestore) return;
          var col = firestore.collection('locations');
          // listen to all docs in the collection and react to changes
          col.onSnapshot(function(snapshot){
            snapshot.docChanges().forEach(function(change){
              var id = change.doc.id;
              var data = change.doc.data();
              if(change.type === 'added' || change.type === 'modified'){
                // batch updates to avoid many synchronous DOM/SVG operations
                pendingUpdates[id] = { latlng: [data.lat, data.lon], ts: data.ts || Date.now(), data: data };
                if(!flushScheduled){ flushScheduled = true; requestAnimationFrame(flushPending); }
              }else if(change.type === 'removed'){
                if(userMarkers[id]){ map.removeLayer(userMarkers[id].marker); delete userMarkers[id]; updateOnlineCount(); }
              }
            });
          }, function(err){ console.warn('Firestore listen error', err); setDebug('listen error: ' + (err && err.message)); });

          // also prune stale markers locally every 15s (shorter threshold)
          setInterval(function(){
            var now = Date.now();
            Object.keys(userMarkers).forEach(function(id){
              var info = userMarkers[id];
              if(info && info.ts && (now - info.ts) > 30000){ // 30s stale
                if(info.marker) map.removeLayer(info.marker);
                delete userMarkers[id];
                updateOnlineCount();
              }
            });
          }, 15000);

          // Attempt to remove my location when user navigates away or hides the page
          function tryRemoveOnExit(){
            try{ removeMyLocation(); }catch(e){}
          }
          window.addEventListener('pagehide', tryRemoveOnExit);
          window.addEventListener('beforeunload', tryRemoveOnExit);
          document.addEventListener('visibilitychange', function(){ if(document.visibilityState === 'hidden') tryRemoveOnExit(); });
        }

        function onChild(snap){
          var id = snap.key;
          var data = snap.val();
          if(!data || !data.lat || !data.lon) return;
          // ignore if this client (we still store self if you want)
          var isSelf = id === clientId;
          var latlng = [data.lat, data.lon];
          if(userMarkers[id]){
            userMarkers[id].ts = data.ts || Date.now();
            userMarkers[id].marker.setLatLng(latlng);
          }else{
            // create a small dot marker
            var opts = { renderer: markerRenderer, radius: 6, color: isSelf ? '#fff' : '#ffb07a', fillColor: isSelf ? '#ff6a00' : '#ff6a00', fillOpacity: isSelf ? 0.9 : 0.9, weight: isSelf ? 2 : 1 };
            var m = L.circleMarker(latlng, opts).addTo(map);
            userMarkers[id] = { marker: m, ts: data.ts || Date.now(), id: id };
          }
          updateOnlineCount();
        }

        // Apply pending updates batched via requestAnimationFrame
        function flushPending(){
          Object.keys(pendingUpdates).forEach(function(id){
            var u = pendingUpdates[id];
            if(!u) return;
            if(userMarkers[id]){
              // skip very tiny movements to avoid jitter
              var cur = userMarkers[id].marker.getLatLng();
              var moved = haversineDistanceMeters(cur.lat, cur.lng, u.latlng[0], u.latlng[1]);
              if(moved < 1) return; // ignore sub-meter differences
              userMarkers[id].ts = u.ts;
              userMarkers[id].marker.setLatLng(u.latlng);
            }else{
              var isSelf = id === clientId;
              var opts = { renderer: markerRenderer, radius: 6, color: isSelf ? '#fff' : '#ffb07a', fillColor: isSelf ? '#ff6a00' : '#ff6a00', fillOpacity: isSelf ? 0.9 : 0.9, weight: isSelf ? 2 : 1 };
              var m = L.circleMarker(u.latlng, opts).addTo(map);
              userMarkers[id] = { marker: m, ts: u.ts || Date.now(), id: id };
            }
          });
          pendingUpdates = {};
          flushScheduled = false;
          updateOnlineCount();
        }

        // Haversine distance in meters
        function haversineDistanceMeters(lat1, lon1, lat2, lon2){
          function toRad(x){ return x * Math.PI / 180; }
          var R = 6371000; // meters
          var dLat = toRad(lat2-lat1);
          var dLon = toRad(lon2-lon1);
          var a = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.cos(toRad(lat1))*Math.cos(toRad(lat2)) * Math.sin(dLon/2)*Math.sin(dLon/2);
          var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
          return R * c;
        }

        function updateOnlineCount(){
          var count = Object.keys(userMarkers).length - (userMarkers[clientId] ? 1 : 0);
          onlineCountEl.textContent = (count>0?count+' users nearby':'' );
        }

        // remove my node when leaving page
        window.addEventListener('beforeunload', function(){ removeMyLocation(); });

        // -------------------------------------------------------

        // Live user location marker (uses browser Geolocation API)
        var userMarker = null;
        var accuracyCircle = null;
  // bottom-right toast for location status
  var statusEl = document.createElement('div');
  statusEl.className = 'location-toast';
  statusEl.style.cssText = 'position:fixed;right:12px;bottom:12px;background:rgba(0,0,0,0.6);color:#fff;padding:8px 12px;border-radius:8px;font-size:13px;z-index:9999';
  statusEl.textContent = '';
  document.body.appendChild(statusEl);

        var watchId = null;
        var locateBtn = document.getElementById('locateBtn');
        function isInAppBrowser(){
          // simple heuristic for in-app browsers
          var ua = navigator.userAgent || '';
          return (/FBAN|FBAV|Instagram|Line|KAKAOTALK|WhatsApp/i).test(ua);
        }

        function startWatching(){
          if(!navigator.geolocation){
            statusEl.textContent = 'Geolocation unsupported';
            return;
          }
          statusEl.textContent = 'Requesting location...';
          // request watchPosition on user gesture
          var lastPublish = 0;
          var publishThrottle = 3500; // ms between publishes
          var lastPublishedLatLng = null;
          var movementThresholdMeters = 10; // only publish if moved > 10 meters
          watchId = navigator.geolocation.watchPosition(function(pos){
            var lat = pos.coords.latitude;
            var lon = pos.coords.longitude;
            var acc = pos.coords.accuracy || 0;
            // add or update marker
            if(!userMarker){
              userMarker = L.circleMarker([lat,lon], {radius:8, color:'#ff6a00', fillColor:'#ff6a00', fillOpacity:1, weight:2}).addTo(map);
            }else{
              userMarker.setLatLng([lat,lon]);
            }
            if(!accuracyCircle){
              accuracyCircle = L.circle([lat,lon], {radius: acc, color:'#ff6a00', weight:1, fillColor:'#ff6a00', fillOpacity:0.08}).addTo(map);
            }else{
              accuracyCircle.setLatLng([lat,lon]);
              accuracyCircle.setRadius(acc);
            }
            statusEl.textContent = 'Location updated';
            // briefly highlight the toast
            statusEl.style.background = 'rgba(255,106,0,0.95)';
            setTimeout(()=>{ statusEl.style.background = 'rgba(0,0,0,0.6)'; }, 900);
            // pan map to user on first fix
            if(map && !map._userCentered){ map.setView([lat,lon], 16); map._userCentered = true; }
            // publish to backend with throttle + movement threshold
            try{
              var now = Date.now();
              var shouldPublish = false;
              if(!lastPublishedLatLng) shouldPublish = true;
              else {
                var d = haversineDistanceMeters(lastPublishedLatLng[0], lastPublishedLatLng[1], lat, lon);
                if(d >= movementThresholdMeters) shouldPublish = true;
              }
              if(shouldPublish && ((now - lastPublish) > publishThrottle)){
                publishLocation(lat, lon, acc); lastPublish = now; lastPublishedLatLng = [lat, lon];
              }
            }catch(e){}
          }, function(err){
            // map common error codes
            if(err && err.code === 1){
              statusEl.textContent = 'Permission denied. Open this page in Safari and allow location.';
            }else if(err && err.code === 3){
              statusEl.textContent = 'Location request timed out.';
            }else{
              statusEl.textContent = 'Location unavailable';
            }
          }, {enableHighAccuracy:true, maximumAge:3000, timeout:10000});
          locateBtn.textContent = 'Stop';
        }

        function stopWatching(){
          if(watchId !== null){
            navigator.geolocation.clearWatch(watchId);
            watchId = null;
          }
          // remove markers from the map so the dot disappears
          if(userMarker){ map.removeLayer(userMarker); userMarker = null; }
          if(accuracyCircle){ map.removeLayer(accuracyCircle); accuracyCircle = null; }
          if(map && map._userCentered){ delete map._userCentered; }
          // remove from realtime backend when stopping
          try{ removeMyLocation(); }catch(e){}
          statusEl.textContent = 'Location stopped';
          locateBtn.textContent = 'Locate';
        }

        if(locateBtn){
          locateBtn.addEventListener('click', function(){
            // heuristic: in-app browsers often block permissions; warn user
            if(isInAppBrowser()){
              statusEl.textContent = 'If permission fails, open this page in Safari for best results.';
            }
            if(watchId === null) startWatching(); else stopWatching();
          });
        }
      });
    </script>
  </div>
</body>
</html>